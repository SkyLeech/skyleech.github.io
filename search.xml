<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++友元</title>
    <url>/2024/05/29/C++%E5%8F%8B%E5%85%83/</url>
    <content><![CDATA[<p>在程序里，有些私有属性也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p>
<p>友元的关键字为<code> friend</code></p>
<p>友元的三种实现</p>
<ul>
<li><p>全局函数做友元</p>
</li>
<li><p>类做友元</p>
</li>
<li><p>成员函数做友元</p>
</li>
</ul>
<h2 id="全局函数做友元"><a href="#全局函数做友元" class="headerlink" title="全局函数做友元"></a>全局函数做友元</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>&#123;</span><br><span class="line">    <span class="comment">//告诉编译器goodGay全局函数是Building类的好朋友，可以访问类中的私有内容</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building *building)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_SittingRoom;<span class="comment">//客厅</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Building</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building *building)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友正在访问：&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友正在访问：&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="类做友元"><a href="#类做友元" class="headerlink" title="类做友元"></a>类做友元</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GoodGay</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GoodGay</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span> &#123;</span><br><span class="line">    <span class="comment">//GoodGay类是本类的好朋友，可以访问本类中私有成员</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">GoodGay</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_SittingRoom;<span class="comment">//客厅</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Building</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">GoodGay::<span class="built_in">GoodGay</span>() &#123;</span><br><span class="line">    building = <span class="keyword">new</span> Building;<span class="comment">//创建建筑物对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GoodGay::visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友正在访问：&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友正在访问：&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    GoodGay gg;</span><br><span class="line">    gg.<span class="built_in">visit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="成员函数做友元"><a href="#成员函数做友元" class="headerlink" title="成员函数做友元"></a>成员函数做友元</h2>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>友元</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C++构造函数的一些注意事项</title>
    <url>/2024/04/23/C++%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><h3 id="拷贝构造函数调用时机"><a href="#拷贝构造函数调用时机" class="headerlink" title="拷贝构造函数调用时机"></a>拷贝构造函数调用时机</h3><p>C++中拷贝构造函数调用时机通常有三种情况</p>
<ul>
<li>使用一个已经创建完毕的对象来初始化一个新对象</li>
<li>值传递的方式给函数参数传值</li>
<li>以值方式返回局部对象</li>
</ul>
<h3 id="注意事项1："><a href="#注意事项1：" class="headerlink" title="注意事项1："></a>注意事项1：</h3><p>调用默认构造函数时候，不要加()</p>
<p>因为下面这行代码，编译器会认为是一个函数的声明，不会认为在创建对象</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="注意事项2："><a href="#注意事项2：" class="headerlink" title="注意事项2："></a>注意事项2：</h3><p>不要利用拷贝构造函数 初始化匿名对象    编译器会认为Person(p3) &#x3D;&#x3D;&#x3D; Person p3（对象声明）</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显示法创建对象</span></span><br><span class="line">Person p2 = <span class="built_in">Person</span>(<span class="number">10</span>); <span class="comment">// 有参构造</span></span><br><span class="line">Person p3 = <span class="built_in">Person</span>(p2); <span class="comment">//拷贝构造</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(p3); <span class="comment">// 不要利用拷贝构造函数初始化匿名对象</span></span><br></pre></td></tr></table></figure></div>





<h2 id="构造函数调用规则"><a href="#构造函数调用规则" class="headerlink" title="构造函数调用规则"></a>构造函数调用规则</h2><p>默认情况下，C++编译器至少给一个类添加3个函数</p>
<ol>
<li>认构造函数（无参，函数体为空）</li>
<li>默认析构函数（无参，函数体为空）</li>
<li>默认拷贝构造函数，对属性进行值拷贝</li>
</ol>
<p>构造函数调用规则如下：</p>
<ul>
<li>如果用户定义<strong>有参</strong>构造函数，C++不在提供默认无参构造，<strong>但是会提供默认拷贝构造</strong></li>
<li>如果用户定义<strong>拷贝</strong>构造函数，<strong>C++不会再提供其他构造函数</strong></li>
</ul>
<h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><p>浅拷贝：简单的赋值拷贝操作</p>
<p>深拷贝：在<strong>堆区</strong>重新申请空间，进行拷贝操作</p>
<p>在类中存在指针类型时会出现的问题：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/04/24/TKfEPg4H9cjkasR.png"
                      alt="image-20240424003444756"
                ></p>
<p><strong>默认</strong>拷贝构造函数只会做<strong>浅拷贝</strong>操作，所以要利用深拷贝进行解决</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person &amp;p)&#123;</span><br><span class="line">    m_Age = p.m_Age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//m_Height = p.m_Height; 编译器默认实现就是这行代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//深拷贝操作</span></span><br><span class="line">    m_Height = <span class="keyword">new</span> <span class="built_in">int</span> (*p.m_Height) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>当然，现在的编译器也会自动解决，不会报错</p>
<h2 id="使用初始化列表方式初始化指针类型成员变量"><a href="#使用初始化列表方式初始化指针类型成员变量" class="headerlink" title="使用初始化列表方式初始化指针类型成员变量"></a>使用初始化列表方式初始化指针类型成员变量</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//new在堆区创建内存</span></span><br><span class="line"><span class="built_in">Rectangle</span>(<span class="type">double</span> width, <span class="type">int</span> len) : <span class="built_in">width</span>(width), <span class="built_in">len</span>(<span class="keyword">new</span> <span class="built_in">int</span>(len)) &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;有参构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>笔记</tag>
        <tag>构造函数</tag>
        <tag>类和对象</tag>
        <tag>注意事项</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker基础</title>
    <url>/2024/05/18/Docker%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="1-Docker基础"><a href="#1-Docker基础" class="headerlink" title="1.Docker基础"></a>1.Docker基础</h2><h3 id="1-1-常见命令"><a href="#1-1-常见命令" class="headerlink" title="1.1.常见命令"></a>1.1.常见命令</h3><p>首先我们来学习Docker中的常见命令，可以参考官方文档：</p>
<p><a class="link"   href="https://docs.docker.com/engine/reference/commandline/cli/" >https://docs.docker.com/engine/reference/commandline/cli/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>Use the Docker command line<br>Docker’s CLI command description and usage</p>
<h4 id="1-1-1-命令介绍"><a href="#1-1-1-命令介绍" class="headerlink" title="1.1.1.命令介绍"></a>1.1.1.命令介绍</h4><p>其中，比较常见的命令有：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
<th>文档地址</th>
</tr>
</thead>
<tbody><tr>
<td>docker pull</td>
<td>拉取镜像</td>
<td><a class="link"   href="https://docs.docker.com/engine/reference/commandline/pull/" >docker pull <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td>docker push</td>
<td>推送镜像到DockerRegistry</td>
<td><a class="link"   href="https://docs.docker.com/engine/reference/commandline/push/" >docker push <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td>docker images</td>
<td>查看本地镜像</td>
<td><a class="link"   href="https://docs.docker.com/engine/reference/commandline/images/" >docker images <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td>docker rmi</td>
<td>删除本地镜像</td>
<td><a class="link"   href="https://docs.docker.com/engine/reference/commandline/rmi/" >docker rmi <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td>docker run</td>
<td>创建并运行容器（不能重复创建）</td>
<td><a class="link"   href="https://docs.docker.com/engine/reference/commandline/run/" >docker run <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td>docker stop</td>
<td>停止指定容器</td>
<td><a class="link"   href="https://docs.docker.com/engine/reference/commandline/stop/" >docker stop <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td>docker start</td>
<td>启动指定容器</td>
<td><a class="link"   href="https://docs.docker.com/engine/reference/commandline/start/" >docker start <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td>docker restart</td>
<td>重新启动容器</td>
<td><a class="link"   href="https://docs.docker.com/engine/reference/commandline/restart/" >docker restart <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td>docker rm</td>
<td>删除指定容器</td>
<td><a class="link"   href="https://docs.docker.com/engine/reference/commandline/rm/" >docs.docker.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td>docker ps</td>
<td>查看容器</td>
<td><a class="link"   href="https://docs.docker.com/engine/reference/commandline/ps/" >docker ps <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td>docker logs</td>
<td>查看容器运行日志</td>
<td><a class="link"   href="https://docs.docker.com/engine/reference/commandline/logs/" >docker logs <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td>docker exec</td>
<td>进入容器</td>
<td><a class="link"   href="https://docs.docker.com/engine/reference/commandline/exec/" >docker exec <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td>docker save</td>
<td>保存镜像到本地压缩文件</td>
<td><a class="link"   href="https://docs.docker.com/engine/reference/commandline/save/" >docker save <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td>docker load</td>
<td>加载本地压缩文件到镜像</td>
<td><a class="link"   href="https://docs.docker.com/engine/reference/commandline/load/" >docker load <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td>docker inspect</td>
<td>查看容器详细信息</td>
<td><a class="link"   href="https://docs.docker.com/engine/reference/commandline/inspect/" >docker inspect <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
</tbody></table>
<h3 id="2-2-数据卷"><a href="#2-2-数据卷" class="headerlink" title="2.2.数据卷"></a>2.2.数据卷</h3><h4 id="2-2-1-什么是数据卷"><a href="#2-2-1-什么是数据卷" class="headerlink" title="2.2.1.什么是数据卷"></a>2.2.1.什么是数据卷</h4><p><strong>数据卷（volume）</strong>是一个虚拟目录，是<strong>容器内目录</strong>与<strong>宿主机****目录</strong>之间映射的桥梁。</p>
<p>以Nginx为例，我们知道Nginx中有两个关键的目录：</p>
<ul>
<li><p>html：放置一些静态资源</p>
</li>
<li><p>conf：放置配置文件</p>
</li>
</ul>
<p>如果我们要让Nginx代理我们的静态资源，最好是放到html目录；如果我们要修改Nginx的配置，最好是找到conf下的nginx.conf文件。</p>
<p>但遗憾的是，容器运行的Nginx所有的文件都在容器内部。所以我们必须利用数据卷将两个目录与宿主机目录关联，方便我们操作。如图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/05/18/o2tCQVIP4qlDJS6.png"
                      alt="image-20240518140210546"
                ></p>
<p>在上图中：</p>
<ul>
<li><p>我们创建了两个数据卷：conf、html</p>
</li>
<li><p>Nginx容器内部的conf目录和html目录分别与两个数据卷关联。</p>
</li>
<li><p>而数据卷conf和html分别指向了宿主机的&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;conf&#x2F;_data目录和&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;html&#x2F;_data目录</p>
</li>
</ul>
<p>这样以来，容器内的conf和html目录就 与宿主机的conf和html目录关联起来，我们称为<strong>挂载</strong>。此时，我们操作宿主机的&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;html&#x2F;_data就是在操作容器内的&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;_data目录。只要我们将静态资源放入宿主机对应目录，就可以被Nginx代理了。</p>
<h4 id="1-2-2-数据卷命令"><a href="#1-2-2-数据卷命令" class="headerlink" title="1.2.2.数据卷命令"></a>1.2.2.数据卷命令</h4><p>数据卷的相关命令有：</p>
<table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>说明</strong></th>
<th><strong>文档地址</strong></th>
</tr>
</thead>
<tbody><tr>
<td>docker volume create</td>
<td>创建数据卷</td>
<td><a class="link"   href="https://docs.docker.com/engine/reference/commandline/volume_create/" >docker volume create <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td>docker volume ls</td>
<td>查看所有数据卷</td>
<td><a class="link"   href="https://docs.docker.com/engine/reference/commandline/volume_ls/" >docs.docker.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td>docker volume rm</td>
<td>删除指定数据卷</td>
<td><a class="link"   href="https://docs.docker.com/engine/reference/commandline/volume_prune/" >docs.docker.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td>docker volume inspect</td>
<td>查看某个数据卷的详情</td>
<td><a class="link"   href="https://docs.docker.com/engine/reference/commandline/volume_inspect/" >docs.docker.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td>docker volume prune</td>
<td>清除数据卷</td>
<td><a class="link"   href="https://docs.docker.com/engine/reference/commandline/volume_prune/" >docker volume prune <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
</tbody></table>
<p>注意：容器与数据卷的挂载要在创建容器时配置，对于创建好的容器，是不能设置数据卷的。而且<strong>创建容器的过程中，数据卷会自动创建</strong>。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Docker</tag>
        <tag>Docker常用命令</tag>
        <tag>Docker数据卷</tag>
      </tags>
  </entry>
  <entry>
    <title>JWT令牌</title>
    <url>/2024/07/24/JWT%E4%BB%A4%E7%89%8C/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/07/25/FDyxNZVftUkeP62.png"
                      alt="image-20240724233933160"
                ></p>
<h2 id="pom坐标"><a href="#pom坐标" class="headerlink" title="pom坐标"></a>pom坐标</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/07/25/oVIEYUHCB3fWalu.png"
                      alt="image-20240724234040083.png"
                ></p>
<h2 id="生成jwt"><a href="#生成jwt" class="headerlink" title="生成jwt"></a>生成jwt</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/07/25/AuzxQn3rZsoXL9I.png"
                      alt="image-20240724235040326.png"
                ></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>JWT</tag>
        <tag>SpringBoot</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript函数操作</title>
    <url>/2024/04/08/JavaScript%E5%87%BD%E6%95%B0%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><p>具名函数</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> 函数名(参数列表) &#123;</span><br><span class="line">    函数体</span><br><span class="line">    <span class="keyword">return</span> 返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getSum</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(num1 + num2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果不传参，默认是undefined</p>
<p>undefined+undefined会出现NaN</p>
<p>形参可以给默认值</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getSum</span>(<span class="params">x = <span class="number">0</span>, y = <span class="number">0</span></span>)&#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(num1 + num2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">函数名()</span><br></pre></td></tr></table></figure></div>



<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>没有名字的函数，无法直接使用</p>
<p>使用方式：</p>
<ul>
<li>函数表达式</li>
<li>立即执行函数</li>
</ul>
<h3 id="1-函数表达式"><a href="#1-函数表达式" class="headerlink" title="1.函数表达式"></a>1.函数表达式</h3><p>将匿名函数赋值给一个变量，并且通过变量名称进行调用我们将这个称为函数表达式</p>
<p>语法：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-立即执行函数"><a href="#2-立即执行函数" class="headerlink" title="2.立即执行函数"></a>2.立即执行函数</h3><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params">形参</span>)&#123;函数体&#125;)(实参); <span class="comment">//立即执行函数必须加分号</span></span><br></pre></td></tr></table></figure></div>



<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><h3 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h3><p>arguments是函数内部内置的伪数组变量，它包含了调用函数时传入的所有实参</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        s += <span class="variable language_">arguments</span>[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><p>剩余参数允许我们将一个不定数量的参数表示为一个数组</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getSum</span>(<span class="params">...other</span>)&#123;</span><br><span class="line">    <span class="comment">// other得到[1,2,3]</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(other)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getSum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></div>



<h2 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h2><p>展开运算符(…)，将一个数组进行展开</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">2</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...arr) <span class="comment">// 1 5 3 8 2</span></span><br></pre></td></tr></table></figure></div>

<p>说明：</p>
<ul>
<li>不会修改原数组</li>
</ul>
<p>使用场景：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">//1 求数组最大最小值</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">max</span>(...arr1)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2 合并数组</span></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> arr = [...arr1, ...arr2]</span><br></pre></td></tr></table></figure></div>



<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>目的：引入箭头函数的目的是更简短的函数写法并且不绑定this，箭头函数的语法比函数表达式更简洁</p>
<p>使用场景：箭头函数更适用于那些本来需要匿名函数的地方</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params">x</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//只有一个形参的时候，可以省略小括号</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = x =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//只有一行代码的时候，可以省略大括号</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = x =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(x)</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//只有一行代码的时候，可以省略return</span></span><br><span class="line"><span class="comment">/*const fn = x =&gt; &#123;</span></span><br><span class="line"><span class="comment">    return x + x</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = x =&gt; x + x</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//箭头函数可以直接返回一个对象(加小括号的函数体返回对象字面量表达式)</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = uname =&gt; (&#123; <span class="attr">uname</span>: uname &#125;);</span><br><span class="line"><span class="title function_">fn</span>(<span class="string">&#x27;zhangsan&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="箭头函数参数"><a href="#箭头函数参数" class="headerlink" title="箭头函数参数"></a>箭头函数参数</h3><p>箭头函数没有arguments动态参数，但是有剩余参数…args</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getSum</span> = (<span class="params">...arr</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        sum += arr[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getSum</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure></div>



<h3 id="箭头函数this"><a href="#箭头函数this" class="headerlink" title="箭头函数this"></a>箭头函数this</h3><p>以前this的指向：谁调用的这个函数，this就指向谁</p>
<p>箭头函数不会创建自己的this，它只会从自己的作用域链的上一层沿用this</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript数组操作</title>
    <url>/2024/04/07/JavaScript%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="声明语法"><a href="#声明语法" class="headerlink" title="声明语法"></a>声明语法</h2><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> 数组名 = [数据<span class="number">1</span>,数据<span class="number">2</span>, ..., 数据n]</span><br><span class="line"><span class="keyword">let</span> 数组名 = <span class="keyword">new</span> <span class="title class_">Array</span>(数据<span class="number">1</span>,数据<span class="number">2</span>, ..., 数据n)</span><br></pre></td></tr></table></figure></div>

<p>数组里可以是任意类型</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">114514</span>,<span class="string">&quot;hello&quot;</span>,<span class="number">2.5</span>]</span><br></pre></td></tr></table></figure></div>



<h2 id="操作数组"><a href="#操作数组" class="headerlink" title="操作数组"></a>操作数组</h2><h3 id="增："><a href="#增：" class="headerlink" title="增："></a>增：</h3><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">push</span>(新增的内容) <span class="comment">//在末尾新增</span></span><br><span class="line">arr.<span class="title function_">unshift</span>(新增的内容) <span class="comment">//在头部新增</span></span><br></pre></td></tr></table></figure></div>

<h3 id="删："><a href="#删：" class="headerlink" title="删："></a>删：</h3><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">pop</span>() <span class="comment">//方法从数组中删除最后一个元素，并返回该元素的值</span></span><br><span class="line">arr.<span class="title function_">shift</span>() <span class="comment">//删除第一个元素</span></span><br><span class="line">arr.<span class="title function_">splice</span>(操作的下标,删除的个数) <span class="comment">//删除指定元素</span></span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础命令</title>
    <url>/2024/09/03/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、Linux的目录结构"><a href="#一、Linux的目录结构" class="headerlink" title="一、Linux的目录结构"></a>一、Linux的目录结构</h2><h3 id="1-Linux的目录结构"><a href="#1-Linux的目录结构" class="headerlink" title="1.Linux的目录结构"></a>1.Linux的目录结构</h3><p>Linux的目录结构是一个树型结构，没有盘符概念，只有一个根目录<code>/</code></p>
<h3 id="2-Linux路径的描述方式"><a href="#2-Linux路径的描述方式" class="headerlink" title="2.Linux路径的描述方式"></a>2.Linux路径的描述方式</h3><p>路径之间的层级关系使用<code>/</code>来表示</p>
<p>如：</p>
<p><code>/usr/local/hello.txt</code></p>
<h2 id="二、Linux命令入门"><a href="#二、Linux命令入门" class="headerlink" title="二、Linux命令入门"></a>二、Linux命令入门</h2><h3 id="1-什么是命令、命令行"><a href="#1-什么是命令、命令行" class="headerlink" title="1.什么是命令、命令行"></a>1.什么是命令、命令行</h3><ul>
<li>命令行：即Linux终端（Terminal），是一种命令提示符页面。以纯“字符”的形式操作系统，可以使用各种字符化命令对系统发出操作指令。</li>
<li>命令：即Linux程序。一个命令就是一个Linux的程序。命令没有图形化页面，可以在命令行（终端中）提供字符化的反馈。</li>
</ul>
<h3 id="2-Linux命令基础格式"><a href="#2-Linux命令基础格式" class="headerlink" title="2.Linux命令基础格式"></a>2.Linux命令基础格式</h3><p><code>command [-options] [parameter]</code></p>
<ul>
<li>command：命令本身</li>
<li>-options:[可选，非必填]命令的一些选项，可以通过选项控制命令的行为细节</li>
<li>parameter:[可选,非必填]命令的参数,多数用于命令的指向目标等</li>
</ul>
<p><em>[]表示可选</em></p>
<h3 id="3-ls命令入门"><a href="#3-ls命令入门" class="headerlink" title="3.ls命令入门"></a>3.ls命令入门</h3><p><code>ls [-a -l -h] [Linux路径]</code></p>
<p>当不使用选项和参数,直接使用ls命令本体,表示：以<strong>平铺</strong>形式,列出当前工作目录下的内容</p>
<ul>
<li><p>-a选项，表示：all的意思，即列出全部文件（包含隐藏的文件&#x2F;文件夹)</p>
<ul>
<li><p>以<code>.</code>开头的，表示是Linux系统的隐藏文件&#x2F;文件夹（只要以<code>.</code>开头，就能自动隐藏）</p>
</li>
<li><p>只有通过-a选项，才能看到这些隐藏的文件&#x2F;文件夹</p>
</li>
</ul>
</li>
<li><p>-l选项，表示：以列表（竖向排列）的形式展示内容，并展示更多信息</p>
</li>
<li><p>-h 表示以易于阅读的形式，列出文件大小，如K、M、G</p>
<ul>
<li>-h选项必须要搭配<code>-l</code>一起使用</li>
</ul>
</li>
</ul>
<p>语法中的选项是可以组合使用的，比如学习的-a和-l可以组合应用。</p>
<p>写法：</p>
<ul>
<li><code>ls -l -a</code></li>
<li><code>ls -la</code></li>
<li><code>ls -al</code></li>
</ul>
<h4 id="HOME目录和工作目录"><a href="#HOME目录和工作目录" class="headerlink" title="HOME目录和工作目录"></a>HOME目录和工作目录</h4><p>Linux系统的命令行终端，在启动的时候，默认会加载：</p>
<ul>
<li>当前登录用户的HOME目录作为当前工作目录，所以ls命令列出的是HOME目录的内容</li>
<li>HOME目录：每个Linux操作用户在Linux系统的个人账户目录，路径在：&#x2F;home&#x2F;用户名<ul>
<li>如，Linux用户是skyleech，其HOME目录是：&#x2F;home&#x2F;skyleech</li>
<li>Windows系统和Linux系统，均设有用户的HOME目录</li>
</ul>
</li>
</ul>
<h3 id="4-cd切换工作目录"><a href="#4-cd切换工作目录" class="headerlink" title="4.cd切换工作目录"></a>4.cd切换工作目录</h3><p>cd命令来自英文：<strong>C</strong>hange <strong>D</strong>irectory<br>语法：<code>cd [Linux路径]</code></p>
<ul>
<li>cd命令无需选项，只有参数，表示要切换到哪个目录下</li>
<li>cd命令直接执行，不写参数，表示回到用户的HOME目录</li>
</ul>
<h3 id="5-pwd查看当前工作目录"><a href="#5-pwd查看当前工作目录" class="headerlink" title="5.pwd查看当前工作目录"></a>5.pwd查看当前工作目录</h3><p>pwd命令来自：<strong>P</strong>rint <strong>W</strong>ork <strong>D</strong>irectory<br>语法：<code>pwd</code></p>
<ul>
<li>pwd命令，无选项，无参数，直接输入pwd即可</li>
</ul>
<h3 id="6-绝对路径和相对路径"><a href="#6-绝对路径和相对路径" class="headerlink" title="6.绝对路径和相对路径"></a>6.绝对路径和相对路径</h3><ul>
<li>绝对路径：以<strong>根目录</strong>为起点，描述路径的一种写法，路径描述以&#x2F;开头</li>
<li>相对路径：以<strong>当前目录</strong>为起点，描述路径的一种写法，路径描述无需以&#x2F;开头</li>
</ul>
<h4 id="特殊路径符："><a href="#特殊路径符：" class="headerlink" title="特殊路径符："></a>特殊路径符：</h4><ul>
<li><code>.</code>表示当前目录，比如cd.&#x2F;Desktop 表示切换到当前目录下的Desktop目录内，和cd Desktop效果一致</li>
<li><code>..</code>表示上一级目录，比如：cd．即可切换到上一级目录，cd..&#x2F;.．切换到上二级的目录</li>
<li><code>~</code>表示HOME目录，比如：Cd～即可切换到HOME目录或cd～&#x2F;Desktop，切换到HOME内的Desktop目录</li>
</ul>
<h3 id="7-mkdir创建目录"><a href="#7-mkdir创建目录" class="headerlink" title="7.mkdir创建目录"></a>7.mkdir创建目录</h3><p>通过mkdir命令可以创建新的目录 （文件夹）<br>mkdir来自英文：<strong>M</strong>a<strong>k</strong>e <strong>Dir</strong>ectory<br>语法：<code>mkdir [-p] Linux路径</code></p>
<ul>
<li>参数必填，表示Linux路径，即要创建的文件夹的路径，相对路径或绝对路径均可</li>
<li>-p选项可选，表示自动创建不存在的父目录，适用于创建连续多层级的目录</li>
</ul>
<h3 id="8-touch创建文件"><a href="#8-touch创建文件" class="headerlink" title="8.touch创建文件"></a>8.touch创建文件</h3><p>语法：<code>touch Linux路径</code></p>
<ul>
<li>touch命令无选项，参数必填，表示要创建的文件路径，相对、绝对、特殊路径符均可以使用</li>
</ul>
<h3 id="9-cat查看文件内容"><a href="#9-cat查看文件内容" class="headerlink" title="9.cat查看文件内容"></a>9.cat查看文件内容</h3><p>语法：<code>cat Linux路径</code></p>
<ul>
<li>cat同样没有选项，只有必填参数，参数表示：被查看的文件路径，相对、绝对、特殊路径符都可以使用</li>
</ul>
<h3 id="10-more查看文件内容"><a href="#10-more查看文件内容" class="headerlink" title="10.more查看文件内容"></a>10.more查看文件内容</h3><p>more命令同样可以查看文件内容，同cat不同的是:</p>
<ul>
<li>cat是直接将内容全部显示出来</li>
<li>more支持翻页，如果文件内容过多，可以一页页的展示</li>
</ul>
<p>语法：<code>more Linux路径</code></p>
<ul>
<li>同样没有选项，只有必填参数，参数表示：被查看的文件路径，相对、绝对、特殊路径符都可以使用</li>
</ul>
<p>Linux系统内置有一个文件，路径为：&#x2F;etc&#x2F;services，可以使用more命令查看</p>
<p><code>more /etc/services</code></p>
<ul>
<li>在查看的过程中，通过空格翻页</li>
<li>通过q退出查看</li>
</ul>
<h3 id="11-cp命令复制文件文件夹"><a href="#11-cp命令复制文件文件夹" class="headerlink" title="11.cp命令复制文件文件夹"></a>11.cp命令复制文件文件夹</h3><p>cp命令可以用于复制文件\文件夹，cp命令来自英文单词：<strong>c</strong>o<strong>p</strong>y<br>语法： <code>cp [-r] 参数1 参数2</code></p>
<ul>
<li>-r选项，可选，用于复制文件夹使用，表示递归</li>
<li>参数1，Linux路径，表示被复制的文件或文件夹</li>
<li>参数2，Linux路径，表示要复制去的地方</li>
</ul>
<h3 id="12-mv移动文件或文件夹"><a href="#12-mv移动文件或文件夹" class="headerlink" title="12.mv移动文件或文件夹"></a>12.mv移动文件或文件夹</h3><p>mv命令可以用于移动文件\文件夹，mv命令来自英文单词：<strong>m</strong>o<strong>v</strong>e<br>语法：<code>mv 参数1 参数2</code></p>
<ul>
<li>参数1，Linux路径，表示被移动的文件或文件夹</li>
<li>参数2，Linux路径，表示要移动去的地方，如果目标不存在，则进行改名，确保目标存在</li>
</ul>
<h3 id="13-rm删除文件、文件夹"><a href="#13-rm删除文件、文件夹" class="headerlink" title="13.rm删除文件、文件夹"></a>13.rm删除文件、文件夹</h3><p>rm命令可用于删除文件、文件夹<br>rm命令来自英文单词：<strong>r</strong>e<strong>m</strong>ove<br>语法：<code>rm [-r -f] 参数1 参数2 ... 参数N</code></p>
<ul>
<li>同cp命令一样，-r选项用于删除文件夹</li>
<li>-f表示force，强制删除（不会弹出提示确认信息）<ul>
<li>普通用户删除内容不会弹出提示，只有root管理员用户删除内容会有提示</li>
<li>所以一般普通用户用不到-f选项</li>
</ul>
</li>
<li>参数1、参数2、…… 、参数N表示要删除的文件或文件夹路径，按照空格隔开</li>
</ul>
<h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><p>rm命令支持通配符<code>*</code>，用来做模糊匹配</p>
<ul>
<li>符号＊表示通配符，即匹配任意内容（包含空），示例：</li>
<li><code>test*</code>，表示匹配任何以test开头的内容</li>
<li><code>*test</code>，表示匹配任何以test结尾的内容</li>
<li>*<code>test</code>*，表示匹配任何包含test的内容</li>
</ul>
<h3 id="14-su切换用户"><a href="#14-su切换用户" class="headerlink" title="14.su切换用户"></a>14.su切换用户</h3><p>语法：<code>su - 用户名</code></p>
<p>可以通过 su－root，并输入密码（和普通用户默认一样）临时切换到root用户体验<br>通过输入exit命令，退回普通用户。（临时用root，用完记得退出，不要一直用）</p>
<h3 id="14-which命令"><a href="#14-which命令" class="headerlink" title="14.which命令"></a>14.which命令</h3><p>语法：<code>which 要查找的命令</code></p>
<p>看所使用的一系列命令的程序文件存放在哪里</p>
<h3 id="15-find命令"><a href="#15-find命令" class="headerlink" title="15.find命令"></a>15.find命令</h3><h4 id="按文件名查找文件"><a href="#按文件名查找文件" class="headerlink" title="按文件名查找文件"></a>按文件名查找文件</h4><p>语法：<code>find 起始路径 - name “被查找文件名&quot;</code></p>
<p>可以使用通配符</p>
<h4 id="按文件大小查找文件"><a href="#按文件大小查找文件" class="headerlink" title="按文件大小查找文件"></a>按文件大小查找文件</h4><p>语法：<code>find 起始路径 -size +|-n[kMG]</code></p>
<ul>
<li>+、－表示大于和小于</li>
<li>n表示大小数字</li>
<li>kMG表示大小单位，k(小写字母)表示kb，M表示MB，G表示GB</li>
</ul>
<p>示例：</p>
<ul>
<li>查找小于10KB的文件：find／-size -10k</li>
<li>查找大于100MB的文件：find／-size +100M</li>
<li>查找大于1GB的文件：find／-size +1G</li>
</ul>
<h3 id="16-grep命令"><a href="#16-grep命令" class="headerlink" title="16.grep命令"></a>16.grep命令</h3><p>可以通过grep命令，从文件中通过关键字过滤文件行。<br>语法：<code>grep [-n] 关键字 文件路径</code></p>
<ul>
<li>选项-n，可选，表示在结果中显示匹配的行的行号。</li>
<li>参数，关键字，必填，表示过滤的关键字，带有空格或其它特殊符号，建议使用<code>&quot; &quot;</code>将关键字包围起来</li>
<li>参数，文件路径，必填，表示要过滤内容的文件路径，可作为内容输入端口</li>
</ul>
<h3 id="17-wc命令做数量统计"><a href="#17-wc命令做数量统计" class="headerlink" title="17.wc命令做数量统计"></a>17.wc命令做数量统计</h3><p>可以通过wc命令统计文件的行数、单词数量等<br>语法：<code>wc [-c -m -l -w] 文件路径</code></p>
<ul>
<li>选项，-c，统计bytes数量</li>
<li>选项，-m，统计字符数量</li>
<li>选项，-l，统计行数</li>
<li>选项，-w，统计单词数量</li>
<li>参数，文件路径，被统计的文件，可作为内容输入端口</li>
</ul>
<h3 id="18-管道符"><a href="#18-管道符" class="headerlink" title="18.管道符"></a>18.管道符</h3><p>管道符：<code>|</code> </p>
<p>管道符的含义是：将管道符左边命令的结果，作为右边命令的输入</p>
<h3 id="19-echo命令"><a href="#19-echo命令" class="headerlink" title="19.echo命令"></a>19.echo命令</h3><p>可以使用echo命令在命令行内输出指定内容<br>语法：<code>echo 输出的内容</code></p>
<ul>
<li>无需选项，只有一个参数，表示要输出的内容，复杂内容可以用””包围</li>
<li>带有空格或\等特殊符号，建议使用双引号包围<ul>
<li>因为不包围的话，空格后很容易被识别为参数2，尽管echo不受影响，但是要养成习惯哦</li>
</ul>
</li>
</ul>
<h4 id="反引号"><a href="#反引号" class="headerlink" title="反引号&#96;"></a>反引号&#96;</h4><p>我们可以通过将命令用反引号（通常也称之为飘号）&#96;将其包围</p>
<p>被&#96;包围的内容，会被作为命令执行，而非普通字符</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo `pwd`</span><br></pre></td></tr></table></figure></div>



<h4 id="重定向符"><a href="#重定向符" class="headerlink" title="重定向符"></a>重定向符</h4><p>重定向符：&gt;和&gt;&gt;</p>
<ul>
<li><p><code>&gt;</code>，将左侧命令的结果，<strong>覆盖</strong>写入到符号右侧指定的文件中</p>
</li>
<li><p><code>&gt;&gt;</code>，将左侧命令的结果，<strong>追加</strong>写入到符号右侧指定的文件中</p>
</li>
</ul>
<h3 id="21-tail命令"><a href="#21-tail命令" class="headerlink" title="21.tail命令"></a>21.tail命令</h3><p>使用tail命令，可以查看文件尾部内容，跟踪文件的最新更改，语法如下：<br><code>tail [-f -数字] Linux路径</code></p>
<ul>
<li>参数，Linux路径，表示被跟踪的文件路径</li>
<li>选项，-f，表示持续跟踪</li>
<li>选项，-数字，表示，查看尾部多少行，不填默认10行</li>
</ul>
<h3 id="22-vi-vim编辑器"><a href="#22-vi-vim编辑器" class="headerlink" title="22.vi\vim编辑器"></a>22.vi\vim编辑器</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>vi\vim是visual interface的简称，是Linux中最经典的文本编辑器<br>同图形化界面中的文本编辑器一样，vi是命令行下对文本文件进行编辑的绝佳选择。<br>vim 是vi的加强版本，兼容vi 的所有指令，不仅能编辑文本，而且还具有 shell 程序编辑的功能，可以不同颜色的字体来辨别语法的正确性，极大方便了程序的设计和编辑性。</p>
<h4 id="vi-vim编辑器的三种工作模式"><a href="#vi-vim编辑器的三种工作模式" class="headerlink" title="vi\vim编辑器的三种工作模式"></a>vi\vim编辑器的三种工作模式</h4><ul>
<li>命令模式（Command mode)<br>命令模式下，所敲的按键编辑器都理解为命令，以命令驱动执行不同的功能。<br>此模型下，不能自由进行文本编辑。</li>
<li>输入模式（Insert mode）<br>也就是所谓的编辑模式、插入模式。<br>此模式下，可以对文件内容进行自由编辑。</li>
<li>底线命令模式（Last line mode）<br>以<code>:</code>开始，通常用于文件的保存、退出。</li>
</ul>
<h4 id="命令模式快捷键"><a href="#命令模式快捷键" class="headerlink" title="命令模式快捷键"></a>命令模式快捷键</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/09/05/F3s4aRZCJUXodKe.png"
                      alt="image-20240905162038869"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/09/05/WmFCxi8ODkIfrQJ.png"
                      alt="image-20240905162216120"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/09/05/NWfjzM3IBKQpRYC.png"
                      alt="image-20240905162854996"
                ></p>
<h4 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/09/05/a7orPk4EV2FZCcv.png"
                      alt="image-20240905163136538"
                ></p>
<h2 id="三、Linux用户和权限"><a href="#三、Linux用户和权限" class="headerlink" title="三、Linux用户和权限"></a>三、Linux用户和权限</h2><h3 id="su和exit命令"><a href="#su和exit命令" class="headerlink" title="su和exit命令"></a>su和exit命令</h3><p>在前面，我们接触过su命令切换到root账户。<br>su命令就是用于账户切换的系统命令，其来源英文单词：<strong>S</strong>witch<strong>U</strong>ser<br>语法：<code>su [-］[用户名]</code></p>
<ul>
<li><p><code>-</code>符号是可选的，表示是否在切换用户后加载环境变量，建议带上</p>
</li>
<li><p>参数：用户名，表示要切换的用户，用户名也可以省略，省略表示切换到root</p>
</li>
<li><p>切换用户后，可以通过<code>exit</code>命令退回上一个用户，也可以使用快捷键：ctrl+d</p>
</li>
<li><p>使用普通用户，切换到其它用户需要输入密码，如切换到root用户</p>
</li>
<li><p>使用root用户切换到其它用户，无需密码，可以直接切换</p>
</li>
</ul>
<h3 id="sudo命令"><a href="#sudo命令" class="headerlink" title="sudo命令"></a>sudo命令</h3><p>在我们得知root密码的时候，可以通过su命令切换到root得到最大权限。<br>但是我们不建议长期使用root用户，避免带来系统损坏。</p>
<p>我们可以使用sudo命令，为普通的命令授权，临时以root身份执行。</p>
<p>语法：<code>sudo 其它命令</code></p>
<ul>
<li>在其它命令之前，带上sudo，即可为这一条命令临时赋予root授权</li>
<li>但是并不是所有的用户，都有权利使用sudo，我们需要为普通用户配置sudo认证</li>
</ul>
<h3 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h3><p>以下命令需root用户执行</p>
<ul>
<li><p>创建用户组<br><code>groupadd 用户组名</code></p>
</li>
<li><p>删除用户组<br><code>groupdel 用户组名</code></p>
</li>
<li><p>创建用户<br>useradd[-g-d]用户名</p>
<ul>
<li>选项：-g指定用户的组，不指定-g，会创建同名组并自动加入，指定-g需要组已经存在，如已存在同名组，必须使用-g</li>
<li>选项：-d指定用户HOME路径，不指定，HOME目录默认在：&#x2F;home&#x2F;用户名</li>
</ul>
</li>
<li><p>删除用户<br>userdel[-r]用户名</p>
<ul>
<li>选项：-r，删除用户的HOME目录，不使用-r，删除用户时，HOME目录保留</li>
</ul>
</li>
<li><p>查看用户所属组<br>id [用户名]</p>
<ul>
<li>参数：用户名，被查看的用户，如果不提供则查看自身</li>
</ul>
</li>
<li><p>修改用户所属组<br>usermod-aG用户组用户名，将指定用户加入指定用户组</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Linux</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown语法学习</title>
    <url>/2024/04/06/MarkDown%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="Markdown-标题语法"><a href="#Markdown-标题语法" class="headerlink" title="Markdown 标题语法"></a>Markdown 标题语法</h2><p>要创建标题，请在单词或短语前面添加井号 (<code>#</code>) 。<code>#</code> 的数量代表了标题的级别。例如，添加三个 <code>#</code> 表示创建一个三级标题 (<code>&lt;h3&gt;</code>) (例如：<code>### My Header</code>)。</p>
<h2 id="Markdown-段落"><a href="#Markdown-段落" class="headerlink" title="Markdown 段落"></a>Markdown 段落</h2><p>要创建段落，请使用空白行将一行或多行文本进行分隔。</p>
<p>不要用空格（spaces）或制表符（ tabs）缩进段落。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/04/06/zWjIoOBgyV2tSks.png"
                      alt="image-20240406204215979"
                ></p>
<h2 id="Markdown-强调语法"><a href="#Markdown-强调语法" class="headerlink" title="Markdown 强调语法"></a>Markdown 强调语法</h2><h3 id="粗体（Bold）"><a href="#粗体（Bold）" class="headerlink" title="粗体（Bold）"></a>粗体（Bold）</h3><p>要加粗文本，请在单词或短语的前后各添加两个星号（asterisks）或下划线（underscores）。如需加粗一个单词或短语的中间部分用以表示强调的话，请在要加粗部分的两侧各添加两个星号（asterisks）。</p>
<table>
<thead>
<tr>
<th>Markdown语法</th>
<th>HTML</th>
<th>预览效果</th>
</tr>
</thead>
<tbody><tr>
<td><code>I just love **bold text**.</code></td>
<td><code>I just love &lt;strong&gt;bold text&lt;/strong&gt;.</code></td>
<td>I just love <strong>bold text</strong>.</td>
</tr>
<tr>
<td><code>I just love __bold text__.</code></td>
<td><code>I just love &lt;strong&gt;bold text&lt;/strong&gt;.</code></td>
<td>I just love <strong>bold text</strong>.</td>
</tr>
<tr>
<td><code>Love**is**bold</code></td>
<td><code>Love&lt;strong&gt;is&lt;/strong&gt;bold</code></td>
<td>Love<strong>is</strong>bold</td>
</tr>
</tbody></table>
<p><strong>加粗了</strong> <strong>这个也是</strong></p>
<p>Markdown 应用程序在如何处理单词或短语中间的下划线上并不一致。为兼容考虑，在单词或短语中间部分加粗的话，请使用星号（asterisks）。</p>
<h3 id="斜体（Italic）"><a href="#斜体（Italic）" class="headerlink" title="斜体（Italic）"></a>斜体（Italic）</h3><p>要用斜体显示文本，请在单词或短语前后添加一个星号（asterisk）或下划线（underscore）。要斜体突出单词的中间部分，请在字母前后各添加一个星号，中间不要带空格。</p>
<table>
<thead>
<tr>
<th>Markdown语法</th>
<th>HTML</th>
<th>预览效果</th>
</tr>
</thead>
<tbody><tr>
<td><code>Italicized text is the *cat&#39;s meow*.</code></td>
<td><code>Italicized text is the &lt;em&gt;cat&#39;s meow&lt;/em&gt;.</code></td>
<td>Italicized text is the <em>cat’s meow</em>.</td>
</tr>
<tr>
<td><code>Italicized text is the _cat&#39;s meow_.</code></td>
<td><code>Italicized text is the &lt;em&gt;cat&#39;s meow&lt;/em&gt;.</code></td>
<td>Italicized text is the <em>cat’s meow</em>.</td>
</tr>
<tr>
<td><code>A*cat*meow</code></td>
<td><code>A&lt;em&gt;cat&lt;/em&gt;meow</code></td>
<td>A<em>cat</em>meow</td>
</tr>
</tbody></table>
<p><em>斜体</em> <em>1</em></p>
<h2 id="粗体（Bold）和斜体（Italic）"><a href="#粗体（Bold）和斜体（Italic）" class="headerlink" title="粗体（Bold）和斜体（Italic）"></a>粗体（Bold）和斜体（Italic）</h2><p>要同时用粗体和斜体突出显示文本，请在单词或短语的前后各添加三个星号或下划线。要加粗并用斜体显示单词或短语的中间部分，请在要突出显示的部分前后各添加三个星号，中间不要带空格。</p>
<table>
<thead>
<tr>
<th>Markdown语法</th>
<th>HTML</th>
<th>预览效果</th>
</tr>
</thead>
<tbody><tr>
<td><code>This text is ***really important***.</code></td>
<td><code>This text is &lt;strong&gt;&lt;em&gt;really important&lt;/em&gt;&lt;/strong&gt;.</code></td>
<td>This text is <em><strong>really important</strong></em>.</td>
</tr>
<tr>
<td><code>This text is ___really important___.</code></td>
<td><code>This text is &lt;strong&gt;&lt;em&gt;really important&lt;/em&gt;&lt;/strong&gt;.</code></td>
<td>This text is <em><strong>really important</strong></em>.</td>
</tr>
<tr>
<td><code>This text is __*really important*__.</code></td>
<td><code>This text is &lt;strong&gt;&lt;em&gt;really important&lt;/em&gt;&lt;/strong&gt;.</code></td>
<td>This text is <em><strong>really important</strong></em>.</td>
</tr>
<tr>
<td><code>This text is **_really important_**.</code></td>
<td><code>This text is &lt;strong&gt;&lt;em&gt;really important&lt;/em&gt;&lt;/strong&gt;.</code></td>
<td>This text is <em><strong>really important</strong></em>.</td>
</tr>
<tr>
<td><code>This is really***very***important text.</code></td>
<td><code>This is really&lt;strong&gt;&lt;em&gt;very&lt;/em&gt;&lt;/strong&gt;important text.</code></td>
<td>This is really<em><strong>very</strong></em>important text.</td>
</tr>
</tbody></table>
<p><em><strong>粗体和斜体</strong></em></p>
<h2 id="Markdown-引用语法"><a href="#Markdown-引用语法" class="headerlink" title="Markdown 引用语法"></a>Markdown 引用语法</h2><p>要创建块引用，请在段落前添加一个 <code>&gt;</code> 符号。</p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">&gt; Dorothy followed her through many of the beautiful rooms in her castle.</span><br></pre></td></tr></table></figure></div>

<p>渲染效果如下所示：</p>
<blockquote>
<p>Dorothy followed her through many of the beautiful rooms in her castle.</p>
</blockquote>
<blockquote>
<p>引用</p>
<p>1</p>
<p>2</p>
<p>3</p>
</blockquote>
<h3 id="嵌套块引用"><a href="#嵌套块引用" class="headerlink" title="嵌套块引用"></a>嵌套块引用</h3><p>块引用可以嵌套。在要嵌套的段落前添加一个 <code>&gt;&gt;</code> 符号。</p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">&gt; Dorothy followed her through many of the beautiful rooms in her castle.</span><br><span class="line">&gt;</span><br><span class="line">&gt;&gt; The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</span><br></pre></td></tr></table></figure></div>

<p>渲染效果如下：</p>
<blockquote>
<p>Dorothy followed her through many of the beautiful rooms in her castle.</p>
<blockquote>
<p>The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</p>
</blockquote>
</blockquote>
<h3 id="带有其它元素的块引用"><a href="#带有其它元素的块引用" class="headerlink" title="带有其它元素的块引用"></a>带有其它元素的块引用</h3><p>块引用可以包含其他 Markdown 格式的元素。并非所有元素都可以使用，你需要进行实验以查看哪些元素有效。</p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">&gt; #### The quarterly results look great!</span><br><span class="line">&gt;</span><br><span class="line">&gt; - Revenue was off the chart.</span><br><span class="line">&gt; - Profits were higher than ever.</span><br><span class="line">&gt;</span><br><span class="line">&gt;  *Everything* is going according to **plan**.</span><br></pre></td></tr></table></figure></div>

<p>渲染效果如下：</p>
<blockquote>
<h4 id="The-quarterly-results-look-great"><a href="#The-quarterly-results-look-great" class="headerlink" title="The quarterly results look great!"></a>The quarterly results look great!</h4><ul>
<li>Revenue was off the chart.</li>
<li>Profits were higher than ever.</li>
</ul>
<p><em>Everything</em> is going according to <strong>plan</strong>.</p>
</blockquote>
<h2 id="Markdown-列表语法"><a href="#Markdown-列表语法" class="headerlink" title="Markdown 列表语法"></a>Markdown 列表语法</h2><p>可以将多个条目组织成有序或无序列表。</p>
<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。</p>
<table>
<thead>
<tr>
<th>Markdown语法</th>
<th>HTML</th>
<th>预览效果</th>
</tr>
</thead>
<tbody><tr>
<td><code>1. First item2. Second item3. Third item4. Fourth item</code></td>
<td><code>&lt;ol&gt;&lt;li&gt;First item&lt;/li&gt;&lt;li&gt;Second item&lt;/li&gt;&lt;li&gt;Third item&lt;/li&gt;&lt;li&gt;Fourth item&lt;/li&gt;&lt;/ol&gt;</code></td>
<td>1. First itemSecond 2. itemThird <br />3. itemFourth item</td>
</tr>
<tr>
<td><code>1. First item1. Second item1. Third item1. Fourth item</code></td>
<td><code>&lt;ol&gt;&lt;li&gt;First item&lt;/li&gt;&lt;li&gt;Second item&lt;/li&gt;&lt;li&gt;Third item&lt;/li&gt;&lt;li&gt;Fourth item&lt;/li&gt;&lt;/ol&gt;</code></td>
<td>First itemSecond itemThird itemFourth item</td>
</tr>
<tr>
<td><code>1. First item8. Second item3. Third item5. Fourth item</code></td>
<td><code>&lt;ol&gt;&lt;li&gt;First item&lt;/li&gt;&lt;li&gt;Second item&lt;/li&gt;&lt;li&gt;Third item&lt;/li&gt;&lt;li&gt;Fourth item&lt;/li&gt;&lt;/ol&gt;</code></td>
<td>First itemSecond itemThird itemFourth item</td>
</tr>
<tr>
<td><code>1. First item2. Second item3. Third item  1. Indented item  2. Indented item4. Fourth item</code></td>
<td><code>&lt;ol&gt;&lt;li&gt;First item&lt;/li&gt;&lt;li&gt;Second item&lt;/li&gt;&lt;li&gt;Third item&lt;ol&gt;&lt;li&gt;Indented item&lt;/li&gt;&lt;li&gt;Indented item&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li&gt;Fourth item&lt;/li&gt;&lt;/ol&gt;</code></td>
<td>First itemSecond itemThird itemIndented itemIndented itemFourth item</td>
</tr>
</tbody></table>
<ol>
<li>first</li>
<li>second</li>
<li>t<ol>
<li>sd</li>
<li>sd</li>
</ol>
</li>
</ol>
<h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。</p>
<table>
<thead>
<tr>
<th>Markdown语法</th>
<th>HTML</th>
<th>预览效果</th>
</tr>
</thead>
<tbody><tr>
<td><code>- First item- Second item- Third item- Fourth item</code></td>
<td><code>&lt;ul&gt;&lt;li&gt;First item&lt;/li&gt;&lt;li&gt;Second item&lt;/li&gt;&lt;li&gt;Third item&lt;/li&gt;&lt;li&gt;Fourth item&lt;/li&gt;&lt;/ul&gt;</code></td>
<td>- First itemSecond itemThird itemFourth item</td>
</tr>
<tr>
<td><code>* First item* Second item* Third item* Fourth item</code></td>
<td><code>&lt;ul&gt;&lt;li&gt;First item&lt;/li&gt;&lt;li&gt;Second item&lt;/li&gt;&lt;li&gt;Third item&lt;/li&gt;&lt;li&gt;Fourth item&lt;/li&gt;&lt;/ul&gt;</code></td>
<td>First itemSecond itemThird itemFourth item</td>
</tr>
<tr>
<td><code>+ First item+ Second item+ Third item+ Fourth item</code></td>
<td><code>&lt;ul&gt;&lt;li&gt;First item&lt;/li&gt;&lt;li&gt;Second item&lt;/li&gt;&lt;li&gt;Third item&lt;/li&gt;&lt;li&gt;Fourth item&lt;/li&gt;&lt;/ul&gt;</code></td>
<td>First itemSecond itemThird itemFourth item</td>
</tr>
<tr>
<td><code>- First item- Second item- Third item  - Indented item  - Indented item- Fourth item</code></td>
<td><code>&lt;ul&gt;&lt;li&gt;First item&lt;/li&gt;&lt;li&gt;Second item&lt;/li&gt;&lt;li&gt;Third item&lt;ul&gt;&lt;li&gt;Indented item&lt;/li&gt;&lt;li&gt;Indented item&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Fourth item&lt;/li&gt;&lt;/ul&gt;</code></td>
<td>First itemSecond itemThird itemIndented itemIndented itemFourth item</td>
</tr>
</tbody></table>
<ul>
<li><p>sd</p>
</li>
<li><p>ds</p>
</li>
<li><p>asd</p>
</li>
<li><p>sd</p>
<ul>
<li>sd</li>
<li>sd</li>
</ul>
</li>
<li><p>sd</p>
</li>
</ul>
<h2 id="Markdown-代码语法"><a href="#Markdown-代码语法" class="headerlink" title="Markdown 代码语法"></a>Markdown 代码语法</h2><p>要将单词或短语表示为代码，请将其包裹在反引号 (&#96;&#96;&#96;) 中。</p>
<table>
<thead>
<tr>
<th>Markdown语法</th>
<th>HTML</th>
<th>预览效果</th>
</tr>
</thead>
<tbody><tr>
<td><code>`At the command prompt, type &#39;nano&#39;.`</code></td>
<td><code>At the command prompt, type &lt;code&gt;nano&lt;/code&gt;.</code></td>
<td>At the command prompt, type <code>nano</code>.</td>
</tr>
</tbody></table>
<h3 id="转义反引号"><a href="#转义反引号" class="headerlink" title="转义反引号"></a>转义反引号</h3><p>如果你要表示为代码的单词或短语中包含一个或多个反引号，则可以通过将单词或短语包裹在双反引号(&#96;&#96;&#96;&#96;)中。</p>
<table>
<thead>
<tr>
<th>Markdown语法</th>
<th>HTML</th>
<th>预览效果</th>
</tr>
</thead>
<tbody><tr>
<td><code>&#39;&#39;Use `code` in your Markdown file.&#39;&#39;</code></td>
<td><code>&lt;code&gt;Use </code>code<code> in your Markdown file.&lt;/code&gt;</code></td>
<td><code>Use `code` in your Markdown file.</code></td>
</tr>
</tbody></table>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="Markdown-分隔线语法"><a href="#Markdown-分隔线语法" class="headerlink" title="Markdown 分隔线语法"></a>Markdown 分隔线语法</h2><p>要创建分隔线，请在单独一行上使用三个或多个星号 (<code>***</code>)、破折号 (<code>---</code>) 或下划线 (<code>___</code>) ，并且不能包含其他内容。</p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">***</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">_________________</span><br></pre></td></tr></table></figure></div>

<p>以上三个分隔线的渲染效果看起来都一样</p>
<h2 id="Markdown-链接语法"><a href="#Markdown-链接语法" class="headerlink" title="Markdown 链接语法"></a>Markdown 链接语法</h2><p>链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。</p>
<p>超链接Markdown语法代码：<code>[超链接显示名](超链接地址 &quot;超链接title&quot;)</code></p>
<p>对应的HTML代码：<code>&lt;a href=&quot;超链接地址&quot; title=&quot;超链接title&quot;&gt;超链接显示名&lt;/a&gt;</code></p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">这是一个链接 [Markdown语法](https://markdown.com.cn)。</span><br></pre></td></tr></table></figure></div>

<p>渲染效果如下：</p>
<p>这是一个链接 <a class="link"   href="https://markdown.com.cn/" >Markdown语法 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p><a class="link"   href="https://baidu.com/" >百度一下 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="给链接增加-Title"><a href="#给链接增加-Title" class="headerlink" title="给链接增加 Title"></a>给链接增加 Title</h3><p>链接title是当鼠标悬停在链接上时会出现的文字，这个title是可选的，它放在圆括号中链接地址后面，跟链接地址之间以空格分隔。</p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">这是一个链接 [Markdown语法](https://markdown.com.cn &quot;最好的markdown教程&quot;)。</span><br></pre></td></tr></table></figure></div>

<p>渲染效果如下：</p>
<p>这是一个链接 <a class="link"   href="https://markdown.com.cn/"  title="最好的markdown教程">Markdown语法 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<h3 id="网址和Email地址"><a href="#网址和Email地址" class="headerlink" title="网址和Email地址"></a>网址和Email地址</h3><p>使用尖括号可以很方便地把URL或者email地址变成可点击的链接。</p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">&lt;https://markdown.com.cn&gt;</span><br><span class="line">&lt;fake@example.com&gt;</span><br></pre></td></tr></table></figure></div>

<p>渲染效果如下：</p>
<p><a class="link"   href="https://markdown.com.cn/" >https://markdown.com.cn <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="mailto:&#x66;&#97;&#107;&#x65;&#64;&#x65;&#x78;&#x61;&#x6d;&#x70;&#108;&#101;&#46;&#x63;&#111;&#x6d;" >&#x66;&#97;&#107;&#x65;&#64;&#x65;&#x78;&#x61;&#x6d;&#x70;&#108;&#101;&#46;&#x63;&#111;&#x6d; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="带格式化的链接"><a href="#带格式化的链接" class="headerlink" title="带格式化的链接"></a>带格式化的链接</h3><p><a class="link"   href="https://markdown.com.cn/basic-syntax/links.html#emphasis" >强调 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 链接, 在链接语法前后增加星号。 要将链接表示为代码，请在方括号中添加反引号。</p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">I love supporting the **[EFF](https://eff.org)**.</span><br><span class="line">This is the *[Markdown Guide](https://www.markdownguide.org)*.</span><br><span class="line">See the section on [`code`](#code).</span><br></pre></td></tr></table></figure></div>

<p>渲染效果如下：</p>
<p>I love supporting the <strong><a class="link"   href="https://eff.org/" >EFF <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></strong>.<br>This is the <em><a class="link"   href="https://www.markdownguide.org/" >Markdown Guide <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></em>.<br>See the section on <a href="https://markdown.com.cn/basic-syntax/links.html#code"><code>code</code></a>.</p>
<h2 id="Markdown-图片语法"><a href="#Markdown-图片语法" class="headerlink" title="Markdown 图片语法"></a>Markdown 图片语法</h2><h3 id="链接图片"><a href="#链接图片" class="headerlink" title="链接图片"></a>链接图片</h3><p>给图片增加链接，请将图像的Markdown 括在方括号中，然后将链接添加在圆括号中。</p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">[![沙漠中的岩石图片](/assets/img/shiprock.jpg &quot;Shiprock&quot;)](https://markdown.com.cn)</span><br></pre></td></tr></table></figure></div>

<p>渲染效果如下：</p>
<p><a href="https://markdown.com.cn/"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://markdown.com.cn/assets/img/shiprock.c3b9a023.jpg"
                      alt="沙漠中的岩石图片"
                ></a></p>
<h2 id="Markdown-任务列表语法"><a href="#Markdown-任务列表语法" class="headerlink" title="Markdown 任务列表语法"></a>Markdown 任务列表语法</h2><p>任务列表使您可以创建带有复选框的项目列表。在支持任务列表的Markdown应用程序中，复选框将显示在内容旁边。要创建任务列表，请在任务列表项之前添加破折号<code>-</code>和方括号<code>[ ]</code>，并在<code>[ ]</code>前面加上空格。要选择一个复选框，请在方括号<code>[x]</code>之间添加 x 。</p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">- [x] Write the press release</span><br><span class="line">- [ ] Update the website</span><br><span class="line">- [ ] Contact the media</span><br></pre></td></tr></table></figure></div>

<ul>
<li><input disabled="" type="checkbox"> 1</li>
<li><input checked="" disabled="" type="checkbox"> 2</li>
</ul>
]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>md</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot-配置文件小知识</title>
    <url>/2024/07/21/SpringBoot-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h2><p>配置文件中<strong>key</strong>的名字必须和实体类中的<strong>属性名</strong>一致</p>
<p>实体类必须有get&#x2F;set方法，所以要加<code>@Data</code>注解</p>
<p>实体类交给ioc容器管理，加上<code>@Component</code></p>
<p>用<code>@ConfigurationProperties</code>指定前缀</p>
<p>例：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;aliyun.oss&quot;)</span></span><br></pre></td></tr></table></figure></div>



<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/07/21/JXawr4dSs1bz6eC.png"
                      alt="image-20240721213105385"
                ></p>
<h2 id="依赖（可选）"><a href="#依赖（可选）" class="headerlink" title="依赖（可选）"></a>依赖（可选）</h2><p>作用：在配置文件中会提示被@ConfigurationProperties标识的bean对象的属性名相对应的配置项的名字</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/07/21/BQzIFdMr6lD4E3g.png"
                      alt="image-20240721215323749"
                ></p>
<h2 id="ConfigurationProperties与-Value"><a href="#ConfigurationProperties与-Value" class="headerlink" title="@ConfigurationProperties与@Value"></a>@ConfigurationProperties与@Value</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/07/21/Lc15pDWAioeNKOr.png"
                      alt="image-20240721215818335"
                ></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>SpringBoot</tag>
        <tag>Java</tag>
        <tag>配置文件</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/04/24/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>! 这是你的第一篇帖子。Check <a class="link"   href="https://hexo.io/docs/" >documentation <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> for more info. 如果您在使用Hexo时遇到任何问题，可以在 <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 中找到答案。 </p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>VUE相关技术</title>
    <url>/2024/04/14/VUE%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="三大部分"><a href="#三大部分" class="headerlink" title="三大部分"></a>三大部分</h3><ul>
<li>结构</li>
<li>样式</li>
<li>逻辑</li>
</ul>
<h3 id="样式冲突"><a href="#样式冲突" class="headerlink" title="样式冲突"></a>样式冲突</h3><p>默认情况：写在组件中的样式会全局生效→因此很容易造成多个组件之间的样式冲突问题。1.全局样式：默认组件中的样式会作用到全局</p>
<p>2.局部样式：可以给组件加上scoped属性，可以让样式只作用于当前组件</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line">    div&#123;</span><br><span class="line">        margin: 30px;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></div>

<p>scoped原理：</p>
<ol>
<li><p>给当前组件模板的所有元素，都会被添加上一个自定义属性data-v-hash值</p>
<p>data-v-5f6a9d565 区分开不同的组件</p>
</li>
<li><p>css选择器后面，被自动处理，添加上了属性选择器</p>
</li>
</ol>
<h3 id="data是一个函数"><a href="#data是一个函数" class="headerlink" title="data是一个函数"></a>data是一个函数</h3><p>一个组件的data 选项必须是一个函数。→保证每个组件实例，维护独立的一份数据对象。每次创建新的组件实例，都会新执行一次data函数，得到一个新对象。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/04/14/cRi96tIVMfXNCg1.png"
                      alt="image-20240414200146044"
                ></p>
<h3 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h3><h4 id="什么是组件通信"><a href="#什么是组件通信" class="headerlink" title="什么是组件通信"></a>什么是组件通信</h4><p>组件通信，就是指组件与组件之间的数据传递。</p>
<ul>
<li><p>组件的数据是独立的，无法直接访问其他组件的数据</p>
</li>
<li><p>想用其他组件的数据 → 组件通信</p>
</li>
</ul>
<h4 id="组件通信解决方案"><a href="#组件通信解决方案" class="headerlink" title="组件通信解决方案"></a>组件通信解决方案</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/04/14/lkfYcrUCGu64eIb.png"
                      alt="image-20240414200701752"
                ></p>
<h4 id="父子通信流程图"><a href="#父子通信流程图" class="headerlink" title="父子通信流程图"></a>父子通信流程图</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/04/14/uUVdX3wmg9hZ8Tb.png"
                      alt="image-20240414200836625"
                ></p>
<h4 id="prop校验"><a href="#prop校验" class="headerlink" title="prop校验"></a>prop校验</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/04/14/q8aNwydfgQr2GDs.png"
                      alt="image-20240414202234860"
                ></p>
<h4 id="prop-data、单向数据流"><a href="#prop-data、单向数据流" class="headerlink" title="prop &amp; data、单向数据流"></a>prop &amp; data、单向数据流</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/04/14/fsyFvM87GJ9RiIX.png"
                      alt="image-20240414202756412"
                ></p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>vue</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>概念POJO、DTO、DAO、PO、BO、VO、QO、ENTITY详解</title>
    <url>/2024/09/07/%E6%A6%82%E5%BF%B5POJO%E3%80%81DTO%E3%80%81DAO%E3%80%81PO%E3%80%81BO%E3%80%81VO%E3%80%81QO%E3%80%81ENTITY%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="一、POJO（Plain-Ordinary-Java-Object-简单Java对象）"><a href="#一、POJO（Plain-Ordinary-Java-Object-简单Java对象）" class="headerlink" title="一、POJO（Plain Ordinary Java Object 简单Java对象）"></a>一、POJO（Plain Ordinary Java Object 简单Java对象）</h2><p>实际就是普通JavaBeans，是为了避免和EJB（Enterprise Java Beans 企业级JavaBeans）混淆所创造的简称，也称为（Plain Old Java Object 又普通又老的对象）。</p>
<p>相比于EJB来说，的确是老的对象，因为ORM中间件的日趋流行，POJO又重新焕发了光彩。</p>
<p>POJO的内在含义是指：那些没有继承任何类、也没有实现任何接口，更没有被其它框架侵入的java对象。<br>它仅包含自身的属性以及自身属性的getter和setter方法，这意味者POJO可以方便的从一个框架迁移到另一个框架中，或者框架升级也会对代码毫无影响，因此而得到复用。</p>
<p>&#x2F;&#x2F;例如在该实体EJB中，实体包含业务逻辑，同时也包含自身的持久化逻辑<br>&#x2F;&#x2F;当更换数据源，或改变中间件框架时，则需要修改大量代码</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> Long id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> Set&lt;Order&gt; orders = <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">	<span class="comment">//省略业务逻辑</span></span><br><span class="line">	<span class="comment">//数据库访问方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="comment">//通过不同方式访问数据库，例如JDBC，Mybaits，JPA</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> Customer <span class="title function_">load</span><span class="params">()</span>&#123;...&#125;</span><br><span class="line">	<span class="keyword">public</span> Customer <span class="title function_">create</span><span class="params">()</span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当改为POJO时，则可以运行在任一JAVA环境中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> Long id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> Set&lt;Order&gt; orders = <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">	<span class="comment">//省略getter和setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>一般，当需要持久化对象时，人们喜欢将该对象放在名为xxxPOJO的目录中。当然，不建议这样命名。<br>POJO实际上是包括BO&#x2F;VO&#x2F;PO&#x2F;DO等一系列对象的总称。有的团队规定禁止命名成xxxPOJO。</p>
<h2 id="二、PO-persistence-object-持久层对象"><a href="#二、PO-persistence-object-持久层对象" class="headerlink" title="二、PO(persistence object 持久层对象)"></a>二、PO(persistence object 持久层对象)</h2><p>对象字段持有的数据需要被持久化到数据表中，参与到持久化操作的对象就被称为持久化对象(persistence object，PO)。</p>
<p>通常，PO是在ORM（对象关系映射）中与数据表的一条记录相匹配，自身属性与数据表字段一一对应。可以将数据表中的一条记录作为一个对象处理，并可以转化为其它对象。</p>
<p>面对不同的数据源时，比如文档型数据库，对象型数据库等时，顾名思义PO是DAO层为进行持久化操作而准备的对象。</p>
<p>包含getter、setter方法。<br>一般不包含业务逻辑与数据库的访问方法。因为数据库本身不包含业务逻辑。<br>PO平常不一定需要实现序列化，只是当采用分布式存储或者需要作为前端输出及远程调用使用时，应该实现序列化</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">//序列化版本，通过IDEA自动生成</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialiVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>；</span><br><span class="line">	<span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;    </span><br><span class="line">    <span class="comment">//省略getter和setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>注意，持久化对象并不一定就是ORM机制（对象关系映射）的数据对象，相反，在领域驱动设计中，持久化对象往往指的就是领域模型对象。</p>
<p>在《阿里巴巴开发手册》中，PO也叫DO（Data Object）数据对象，与数据库表结构一一对应，通过DAO层向上传输数据源对象。</p>
<h2 id="三、DAO-data-access-object-数据访问对象"><a href="#三、DAO-data-access-object-数据访问对象" class="headerlink" title="三、DAO(data access object 数据访问对象)"></a>三、DAO(data access object 数据访问对象)</h2><p>包含对数据的访问，负责持久层的操作 。通常需要结合PO来访问数据库，主要用来封装对数据的访问，并不转化成其它对象。<br>在基于“事务脚本”的业务设计时，它包含业务逻辑。否则，一般只包含持久化的封装。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Dao</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">insert</span><span class="params">(User user)</span>;</span><br><span class="line">    User <span class="title function_">selectById</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="四、DTO（Data-Transfer-Object-数据传输对象）"><a href="#四、DTO（Data-Transfer-Object-数据传输对象）" class="headerlink" title="四、DTO（Data Transfer Object 数据传输对象）"></a>四、DTO（Data Transfer Object 数据传输对象）</h2><p>数据传输对象，是在应用网络层需要传输的对象，是一个为了减少方法调用次数而在进程间传输数据的对象。</p>
<p>在《阿里巴巴开发手册中》规定是Service 或 Manager 向外传输的对象。</p>
<p>DTO模式诞生的背景是分布式通信。考虑到网络传输的损耗与不可靠性，设计分布式服务需遵循一个总体原则：尽可能设计粗粒度的服务，每个服务的方法应代表一个完整的功能，而不是功能的一个步骤。粗粒度服务可以减少服务调用的次数，从而减少不必要的网络通信，同时也能避免对分布式事务的支持。<br>某些人称这个为“值对象”，当然还是有稍许区别。值对象追求对象不可变，DTO的对象是可修改，可改变的。</p>
<p>1.什么是DTO?<br>从输入来看，在进行请求时，应用在接口接收传入对象，然后又转换成实体进行持久化。在此过程中，传入的对象就是DTO。<br>它的命名方式可能是Param、Query 、Command、等。Param 为查询参数对象，适用于各层，一般用做接受前端参数对象。Param 和 Query 的出现是为了不使用 Map 做为接收参数的对象。<br>从输出来看，在进行返回响应时，若数据表有100个字段，那么PO中就有100个属性，而界面可能只需要其中10个属性，那么查询数据库后，对象就需要由PO转化成DTO。<br>DTO可能还需要组合多个表查询到的对象成为一个大对象，以便减少网络的调用，或者给前端传输一些不在数据库中查到的属性，所以需要添加属性。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码，继承实体类，从查询到的PO中添加属性返回给前端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDTO</span> <span class="keyword">extends</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">//序列化版本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialiVersionUID</span> <span class="operator">=</span> <span class="number">2L</span>；</span><br><span class="line">    <span class="comment">//用户标识</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span>&#123;<span class="keyword">return</span> username;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span>&#123;<span class="built_in">this</span>.username= username;&#125;</span><br><span class="line">    <span class="comment">//添加额外属性</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Object&gt; extProperties;        </span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;String, Object&gt; <span class="title function_">getExtProperties</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> extProperties;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setExtProperties</span><span class="params">(HashMap&lt;String, Object&gt; extProperties)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.extProperties = extProperties;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>2.DTO里面有什么？<br>一般不建议创建DTO，因为里面就一些属性和getter、setter方法，业务价值小，作用仅仅是在一次调用中传输几部分信息。<br>其中，属性必须为原始数据类型，因为DTO需要被序列化以便能在连接中传播。<br>它只包含自身数据的存储，而不包含业务逻辑。<br>在不同的客户端之间，通常需要DTO组装器完成领域对象和DTO之间的转化。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DTOAssembler</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> DTO <span class="title function_">createDTO</span><span class="params">(DO domainObject)</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateDO</span><span class="params">(DTO  dataTransferObject)</span>;</span><br><span class="line">	<span class="keyword">public</span> DO <span class="title function_">createDO</span><span class="params">(DTO  dataTransferObject)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>3.DTO怎么使用？<br>对于不同的客户端展现，可以选择一次封装所有可能的数据组成DTO，也可以为每种展现创建不同的DTO。各有利弊。</p>
<p>单个大DTO，减少调用次数，只用创建一次，但是难以掌握传输的数据</p>
<p>不同的小DTO，要创建很多DTO，传输数据很清晰</p>
<p>对于输入方和输出方，可以共用一个DTO，也可以各准备一个DTO，视情况而定。</p>
<p>有部分团队 RPC 的请求和响应参数都通过 DTO 来承载，通过 XXRequestDTO 和 XXResponseDTO 来表示。</p>
<h2 id="五、Entity（实体）"><a href="#五、Entity（实体）" class="headerlink" title="五、Entity（实体）"></a>五、Entity（实体）</h2><p>实体，顾名思义，实体需要给予一个唯一标识，以区分其它实体，而值对象VO不需要。<br>实体应该有一个生命周期，是有状态的，例如抽象订单有一个唯一识别号，订单有从下单创建到最后交货完成的生命周期，实体对象的状态可以变化。</p>
<p>1.与VO(值对象)的区别：<br>只要两个实体对象的唯一标识相等，就判断两个对象相等，即使其他属性不同。可以修改实体状态。<br>而VO(值对象）没有标识，所有属性相等，才判断两个对象相等。只能创建新的值对象，不能修改。</p>
<p>2.与PO（持久化对象）的区别：<br>PO与数据表的一条记录对应，通常为了方便存储，会给PO赋予了一个主键ID。<br>从而，PO也像实体一样具有了标识，Martin Flowler称之为委派标识，区别于实体标识。<br>例如身份证号作为身份证的实体标识，唯一区分其他身份证。但是存储在数据库中，依然可能分配自增主键ID(1,2,3,…)。若值对象需要持久化，也会被分配委派标识，方便查询，或与外键关联。<br>实体的标识与业务有关，PO的委派标识仅方便存储，与技术有关。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Entity</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span>&#123;<span class="keyword">return</span> id;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="六、VO-value-object-值对象）"><a href="#六、VO-value-object-值对象）" class="headerlink" title="六、VO(value object 值对象）"></a>六、VO(value object 值对象）</h2><p>值对象，通常用于业务层之间的数据传递，仅仅包含自身的数据。<br>与实体的区别是，没有唯一标识，无生命周期，内部值是不变的。<br>与PO的区别是，PO只在数据层，作为存储。VO在商业逻辑层和表示层，作为一个概念整体。</p>
<p>值对象通常是小而简单的对象，如货币、日期或地址这样的对象，判断相等时不根据标识ID。比如，年月日相同，就判断这两个对象相等。<br>值对象易于创建，参数传递时通常是传递值，而不是传递引用。<br>值对象不应被持久化，这个对象被创建后只能被引用，当没有引用时交给垃圾回收自动处理。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码,比如Address这样无唯一标识的就是值对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String country;</span><br><span class="line">    <span class="keyword">private</span> String province;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Address</span><span class="params">(String country, String province, String city)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.country= country;</span><br><span class="line">        <span class="built_in">this</span>.province= province;</span><br><span class="line">        <span class="built_in">this</span>.city= city;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略equals方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用值对象，若要修改值对象，值对象不用维护，直接创建一个全新的Address对象</span></span><br><span class="line"><span class="comment">//原对象直接被抛弃，而不是在原对象上进行修改</span></span><br><span class="line"><span class="keyword">public</span> Address <span class="title function_">changeAddress</span><span class="params">(String newCity, String newProvince, String newCity)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Address</span>(newCity, newProvince, newCity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>理解了VO的意思，也就明白了，某些DTO也是一种值对象。历史上，在Martin Flowler称“值对象”的术语，在J2EE社团中称为“数据传输对象”，这在设计模式界引起了一场混乱。</p>
<h2 id="七、VO（-View-Object-显示层对象）"><a href="#七、VO（-View-Object-显示层对象）" class="headerlink" title="七、VO（ View Object 显示层对象）"></a>七、VO（ View Object 显示层对象）</h2><p>Value Object和View Object的简写都是VO，可能容易弄混。View Object的含义是通常是Web向模板渲染引擎层传输的对象。《阿里巴巴开发手册》中建议把输出的显示层对象命名为VO。当然，也有人把这个对象命名为DTO作为传输。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Controller层</span></span><br><span class="line"><span class="keyword">public</span> HttpResult <span class="title function_">list</span><span class="params">(<span class="meta">@RequestBody</span> XXParam param)</span>&#123;</span><br><span class="line">    HttpResult vo=HttpResultUtils.convert(XXDTO);</span><br><span class="line">    <span class="keyword">return</span> vo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>由于很多页面需要额外数据，比如错误码、提示信息、分页信息等，查询的DTO之后需要再封装成View Object 显示层对象再显示出来</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	errcode: <span class="string">&quot;00000&quot;</span>,</span><br><span class="line">	errmsg: <span class="string">&quot;ok&quot;</span>,</span><br><span class="line">	data: &#123;</span><br><span class="line">		pageNum: <span class="number">1</span>, </span><br><span class="line">		pageSize: <span class="number">10</span>, </span><br><span class="line">		totalPage: <span class="number">1</span>, </span><br><span class="line">		total: <span class="number">4</span>, </span><br><span class="line">		list: [...]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="八、BO-business-object-业务对象"><a href="#八、BO-business-object-业务对象" class="headerlink" title="八、BO(business object 业务对象)"></a>八、BO(business object 业务对象)</h2><p>业务对象(business object，BO)是企业领域用来描述业务概念的语义对象。这是一个非常宽泛的定义。</p>
<p>业务对象，就是把业务逻辑封装为一个对象（注意是对象本身的业务逻辑，而不是协调其它对象的逻辑），这个业务对象可以包括一个或多个其它的对象。</p>
<p>一些业务建模方法使用了业务对象的概念，如SAP定义的公共事业模型，就将客户相关信息抽象为合作伙伴、合同账户、合同、连接对象等业务对象。它是站在一个高层次角度的表述，并形成了高度抽象的业务概念。</p>
<p>如果系统采用经典三层架构，可认为业务对象就是定义在业务逻辑层中封装了业务逻辑的对象。</p>
<p>一般，实现业务的通常方式之一，是包括数据而不包含行为的领域对象（所谓“贫血模型”）+Service类来实现的。其中，业务逻辑是包含在service层里，随着业务不断演进，service类里的逻辑越来越复杂，越来越重，不利于重用。</p>
<p>而在《面向领域驱动设计》中，将对象本身的逻辑也封装在对象中（所谓“充血模型”），而service类仅仅起协调作用，比如对领域对象的调用及其它工具的调用，不包含业务本身的逻辑，是轻量级的薄薄一层，名为应用服务层。当业务不断演进时，通常只需要关注业务对象（BO）即可，而应用层面较少变化。<br>因此，业务对象，也是领域对象（Domain Object）的另一说法。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">//对象自身的业务逻辑</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changePassword</span><span class="params">(String newPassword)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.setPassword(newPassword);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略getter和setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>业务对象（BO）通常是实体，或者是聚合根，包含多个实体或值对象，内部实现业务逻辑。</p>
<p>此对象在实际使用中有不一样的理解，有的团队将 BO 当作 Service 返回给上层的 “专用 DTO” 使用；而有的团队则当作 Service 层内保存中间信息数据的 “DTO” 或者上下文对象来使用（建议采用这种理解）。</p>
<h2 id="九、QO-query-object-查询对象）"><a href="#九、QO-query-object-查询对象）" class="headerlink" title="九、QO(query object 查询对象）"></a>九、QO(query object 查询对象）</h2><p>数据查询对象，各层接收上层的查询请求。注意，【强制】如果超过2个参数的查询封装，则禁止使用Map类传输。<br>查询对象用于 Controller 层方法接收客户端的请求参数。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyQO</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String param1;</span><br><span class="line">  <span class="keyword">private</span> String param2;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@PostMapping(&quot;/post&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">post</span><span class="params">(<span class="meta">@RequestBody</span> MyQO qo)</span> &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


<p>以创建简历对象为例，简历可分为教育经历、工作经历、项目经历。先填写查询对象的信息，转换为业务对象，分成不同的表进行存储。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MyBO</span> <span class="variable">bo</span> <span class="operator">=</span> service.createBO(qo);<span class="comment">//创建业务对象</span></span><br><span class="line">bo.dosomething();</span><br><span class="line"><span class="comment">//将业务对象存储在不同的表中</span></span><br><span class="line"><span class="type">MyPO</span> <span class="variable">po1</span> <span class="operator">=</span> service.createPO1(bo);</span><br><span class="line">dao1.save(po1);</span><br><span class="line"><span class="type">MyPO</span> <span class="variable">po2</span> <span class="operator">=</span> service.createPO2(bo);</span><br><span class="line">dao2.save(po2);</span><br><span class="line"><span class="type">MyPO</span> <span class="variable">po3</span> <span class="operator">=</span> service.createPO3(bo);</span><br><span class="line">dao3.save(po3);</span><br></pre></td></tr></table></figure></div>

<h2 id="十、AO-Application-Object-应用对象"><a href="#十、AO-Application-Object-应用对象" class="headerlink" title="十、AO (Application Object 应用对象)"></a>十、AO (Application Object 应用对象)</h2><p>一般用在控制层和服务层之间。有些团队会将前端查询的属性和保存的属性几乎一致的对象封装为 AO，如读取用户属性传给前端，用户在前端编辑了用户属性后传回后端。这种用法将 AO 用做 Param 和 VO 或 Param 和 DTO 的组合。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Controller层</span></span><br><span class="line"><span class="keyword">public</span> HttpResult <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> XXAO ao1)</span>&#123;</span><br><span class="line">	<span class="type">XXAO</span> <span class="variable">ao2</span> <span class="operator">=</span> XXService.update(ao1);</span><br><span class="line">    <span class="type">HttpResult</span> <span class="variable">vo</span> <span class="operator">=</span> HttpResultUtils.convert(ao2);</span><br><span class="line">    <span class="keyword">return</span> vo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="十一、总结"><a href="#十一、总结" class="headerlink" title="十一、总结"></a>十一、总结</h2><p>POJO：简单Java对象，它没有任何限制和特定的约定，是一个普通的Java对象。<br>DTO：数据传输对象，它是一个数据传输结构，通常用于不同进程间的数据传输，在不同层之间传递数据的对象。<br>DAO：数据访问对象，是一个数据访问模式，在应用程序中它通常扮演着对数据库的访问。<br>PO：持久化对象，通常指ORM（对象关系映射）中映射的数据库表对应的实体类。<br>BO：业务对象，是应用程序中业务逻辑的实现。<br>VO：值对象，它是一个用于存储数据的对象，通常是与UI&#x2F;界面模型相关的对象。<br>QO（Query）：查询对象，它主要用于定义查询条件和规则，用于接收前端传递的查询条件参数。<br>ENTITY：实体对象，是一个与业务相关的对象，通常是与应用程序领域模型相关的对象。<br>Param：表示请求参数，用于接收前端传递的参数<br>Command：表示命令，用于接收前端传递的命令参数</p>
<blockquote>
<p>各对象的命名习惯：</p>
<ul>
<li>PO通常放在名为bean、entity、model目录中。</li>
<li>DAO本身就是一层，通常是DAO、mapper、repository目录。</li>
<li>BO通常在service、manager、business，domain，model目录中。</li>
<li>DTO通常在command、representation、DTO目录中。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Java</tag>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title>面试八股文</title>
    <url>/2024/09/11/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/</url>
    <content><![CDATA[<h2 id="Redis篇"><a href="#Redis篇" class="headerlink" title="Redis篇"></a>Redis篇</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/09/11/kwr9SFuxadAMeXB.png"
                      alt="image-20240911230740946"
                ></p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>查询一个不存在的数据，mysql查询不到数据也不会直接写入缓存，就会导致每次请求都查数据库</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">解决方案一：缓存空数据，查询返回的数据为空，仍把这个空结果进行缓存</span><br><span class="line">优点：简单</span><br><span class="line">缺点：消耗内存，可能会发生数据不一致的问题</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">解决方案二：布隆过滤器</span><br><span class="line">优点：内存占用较少，没有多余key</span><br><span class="line">缺点：实现复杂，存在误判</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/09/11/i2SkDq1Wp4HgrEP.png"
                      alt="image-20240911232215854"
                ></p>
<p>布隆过滤器作用：检索一个元素是否在一个集合中。</p>
<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>给某一个key设置了过期时间，当key过期的时候，恰好这时间点对这个key有大量的并发请求过来，这些并发请求可能会瞬间把DB压垮</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">解决方案一：互斥锁，强一致，性能差</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">解决方案二：逻辑过期,高可用，性能优，不能保证数据绝对一致</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/09/11/SJQKMzXvs49GTdH.png"
                      alt="image-20240911233104772"
                ></p>
<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力</p>
<p>解决方案：</p>
<ul>
<li>给不同的Key的TTL添加随机值</li>
<li>利用Redis集群提高服务的可用性（哨兵模式、集群模式）</li>
<li>给缓存业务添加降级限流策略（nginx或spring cloud gateway）（降级可做为系统的保底策略，适用于穿透、击穿、雪崩）</li>
<li>给业务添加多级缓存 （Guava或Caffeine）</li>
</ul>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h2 id="数据库篇"><a href="#数据库篇" class="headerlink" title="数据库篇"></a>数据库篇</h2>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Mybatis-Plus与Spring版本兼容问题</title>
    <url>/2024/10/13/%E5%85%B3%E4%BA%8EMybatis-Plus%E4%B8%8ESpring%E7%89%88%E6%9C%AC%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="Spring-Boot-升级-3-2-报错-Invalid-value-type-for-attribute-‘factoryBeanObjectType’-java-lang-String"><a href="#Spring-Boot-升级-3-2-报错-Invalid-value-type-for-attribute-‘factoryBeanObjectType’-java-lang-String" class="headerlink" title="Spring Boot 升级 3.2 报错 Invalid value type for attribute ‘factoryBeanObjectType’: java.lang.String"></a>Spring Boot 升级 3.2 报错 Invalid value type for attribute ‘factoryBeanObjectType’: java.lang.String</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>升级 Spring Boot 3.2 版本项目启动报错：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">java.lang.IllegalArgumentException: Invalid value <span class="built_in">type</span> <span class="keyword">for</span> attribute <span class="string">&#x27;factoryBeanObjectType&#x27;</span>: java.lang.String</span><br></pre></td></tr></table></figure></div>



<h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>mybatis-spring 官方 ISSUE: <a class="link"   href="https://github.com/mybatis/spring/issues/855" >https://github.com/mybatis/spring/issues/855 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>项目中使用 mybatis-plus-boot-starter 当前最新版本 3.5.4.1 ，其中依赖的 mybatis-spring 版本为 2.1.1</p>
<p>在 mybatis-spring 2.1.1 版本的 ClassPathMapperScanner#processBeanDefinitions 方法里将 <code>BeanClassName </code>赋值给 String 变量</p>
<p>并将 <code>beanClassName</code> 赋值给 <code>factoryBeanObjectType</code></p>
<p>但是在 Spring Boot 3.2 版本中FactoryBeanRegistrySupport#getTypeForFactoryBeanFromAttributes方法已变更，如果 factoryBeanObjectType 不是 ResolvableType 或 Class 类型会抛出 IllegalArgumentException 异常。</p>
<p>此时因为 factoryBeanObjectType 是 String 类型，不符合条件而抛出异常。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>Mybatis-Plus 于 2023年12月24日发布 <a class="link"   href="https://github.com/baomidou/mybatis-plus/releases/tag/v3.5.5" >mybatis-plus v3.5.5 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 版本，发布日志声明 <code>升级spring-boot3版本mybatis-spring至3.0.3</code>。</p>
<p>所以升级 Mybatis-Plus 版本为 3.5.5 版本即可，需要注意下 Maven 的坐标标识 是<code>mybatis-plus-spring-boot3-starter</code>，这点和SpringBoot 2 的依赖坐标<code>mybatis-plus-boot-starter</code>有所区别。<strong>（这点尤其注意，因为笔者就是在此卡了3小时🥲）</strong></p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-spring-boot3-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>SpringBoot</tag>
        <tag>Bug</tag>
        <tag>Mybatis-Plus</tag>
      </tags>
  </entry>
</search>
